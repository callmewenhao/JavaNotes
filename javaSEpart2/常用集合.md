# å¸¸ç”¨é›†åˆ

## List

æ¥å£ï¼š`java.util.List<>`

å®ç°ï¼š
- `java.util.ArrayList<>`ï¼šå˜é•¿æ•°ç»„
- `java.util.LinkedList<>`ï¼šåŒé“¾è¡¨

å‡½æ•°ï¼š
- `add()`ï¼šåœ¨æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ 
- `clear()`ï¼šæ¸…ç©º
- `size()`ï¼šè¿”å›é•¿åº¦
- `isEmpty()`ï¼šæ˜¯å¦ä¸ºç©º
- `get(i)`ï¼šè·å–ç¬¬iä¸ªå…ƒç´ 
- `set(i, val)`ï¼šå°†ç¬¬iä¸ªå…ƒç´ è®¾ç½®ä¸ºval

## Stack && Deque

> æ³¨æ„ java åŸæœ¬çš„ **Stack ç±»**è¢« **Deque æ¥å£**ä»£æ›¿ ğŸ¥³
> 
> A more complete and consistent set of LIFO stack operations is provided by the **Deque interface** and its implementations, which should be used in preference to this class. For example:
> 
> `Deque<Integer> stack = new ArrayDeque<Integer>();`
> 
> æ³¨æ„ï¼šDeque æ¥å£æ˜¯ä¸€ä¸ªç»§æ‰¿äº† Queue æ¥å£çš„å­æ¥å£

æ¥å£ï¼š`java.util.Deque<>`

å®ç°ï¼š
- `java.util.ArrayDeque<>`ï¼šåŒç«¯é˜Ÿåˆ—
- `java.util.LinkedList<>`ï¼šåŒé“¾è¡¨

å‡½æ•°ï¼š
- ä½œä¸º é˜Ÿåˆ—ï¼ˆFIFOï¼‰ ä½¿ç”¨æ—¶çš„æ–¹æ³•
    * é˜Ÿåˆ—æ–¹æ³•	ç­‰æ•ˆçš„åŒç«¯é˜Ÿåˆ—æ–¹æ³•
    * `add(e)` == `addLast(e)` å…¥é˜Ÿ
    * `remove()` == `removeFirst()` å‡ºé˜Ÿ
    * `offer(e)` == `offerLast(e)` å…¥é˜Ÿ
    * `poll()` == `pollFirst()` å‡ºé˜Ÿ
    * `element()` == `getFirst()` é˜Ÿå¤´
    * `peek()` == `peekFirst()` é˜Ÿå¤´

- ä½œä¸º å †æ ˆï¼ˆFILOï¼‰ ä½¿ç”¨æ—¶çš„æ–¹æ³•ï¼š
    * å †æ ˆæ–¹æ³•	ç­‰æ•ˆçš„åŒç«¯é˜Ÿåˆ—æ–¹æ³•
    * `push(e)` == `addFirst(e)` å…¥æ ˆ
    * `pop(e)` == `removeFirst(e)` å‡ºæ ˆ
    * `peek()` == `peekFirst()` æ ˆé¡¶

## Queue

æ¥å£ï¼š`java.util.Queue<>`

å®ç°ï¼š
- `java.util.LinkedList<>`ï¼šåŒé“¾è¡¨
- `java.util.PriorityQueue<>`ï¼šä¼˜å…ˆé˜Ÿåˆ—
é»˜è®¤æ˜¯å°æ ¹å †ï¼Œå¤§æ ¹å †å†™æ³•ï¼š`new PriorityQueue<>(Collections.reverseOrder())`
- `java.util.ArrayDeque<>`ï¼šåŒç«¯é˜Ÿåˆ—

å‡½æ•°ï¼š
- `add()`ï¼šåœ¨é˜Ÿå°¾æ·»åŠ å…ƒç´ 
- `remove()`ï¼šåˆ é™¤å¹¶è¿”å›é˜Ÿå¤´
- `isEmpty()`ï¼šæ˜¯å¦ä¸ºç©º
- `size()`ï¼šè¿”å›é•¿åº¦
- `peek()`ï¼šè¿”å›é˜Ÿå¤´
- `clear()`ï¼šæ¸…ç©º

## Set

æ¥å£ï¼š`java.util.Set<K>`

å®ç°ï¼š
- `java.util.HashSet<K>`ï¼šå“ˆå¸Œè¡¨
- `java.util.TreeSet<K>`ï¼šå¹³è¡¡æ ‘ã€çº¢é»‘æ ‘

å‡½æ•°ï¼š
- `add()`ï¼šæ·»åŠ å…ƒç´ 
- `contains()`ï¼šæ˜¯å¦åŒ…å«æŸä¸ªå…ƒç´ 
- `remove()`ï¼šåˆ é™¤å…ƒç´ 
- `size()`ï¼šè¿”å›å…ƒç´ æ•°
- `isEmpty()`ï¼šæ˜¯å¦ä¸ºç©º
- `clear()`ï¼šæ¸…ç©º
- `java.util.TreeSet` å¤šçš„å‡½æ•°ï¼š
    - `ceiling(key)`ï¼šè¿”å›å¤§äºç­‰äºkeyçš„æœ€å°å…ƒç´ ï¼Œä¸å­˜åœ¨åˆ™è¿”å›null
    - `floor(key)`ï¼šè¿”å›å°äºç­‰äºkeyçš„æœ€å¤§å…ƒç´ ï¼Œä¸å­˜åœ¨åˆ™è¿”å›null

## Map
æ¥å£ï¼š`java.util.Map<K, V>`

å®ç°ï¼š
- `java.util.HashMap<K, V>`ï¼šå“ˆå¸Œè¡¨
- `java.util.TreeMap<K, V>`ï¼šå¹³è¡¡æ ‘ã€çº¢é»‘æ ‘

å‡½æ•°ï¼š
- `put(key, value)`ï¼šæ·»åŠ å…³é”®å­—å’Œå…¶å¯¹åº”çš„å€¼
- `get(key)`ï¼šè¿”å›å…³é”®å­—å¯¹åº”çš„å€¼
- `getOrDefault(Object key, V defaultValue)`ï¼šè¿”å›å…³é”®å­— k å¯¹åº”çš„å€¼ï¼Œå¦‚æœæ²¡æœ‰å°±è¿”å› v
- `containsKey(key)`ï¼šæ˜¯å¦åŒ…å«å…³é”®å­—
- `remove(key)`ï¼šåˆ é™¤å…³é”®å­—
- `size()`ï¼šè¿”å›å…ƒç´ æ•°
- `isEmpty()`ï¼šæ˜¯å¦ä¸ºç©º
- `clear()`ï¼šæ¸…ç©º
- `entrySet()`ï¼šè·å–Mapä¸­çš„æ‰€æœ‰å¯¹è±¡çš„é›†åˆ
- `Map.Entry<K, V>`ï¼šMapä¸­çš„å¯¹è±¡ç±»å‹
- `getKey()`ï¼šè·å–å…³é”®å­—
- `getValue()`ï¼šè·å–å€¼
- `java.util.TreeMap<K, V>` å¤šçš„å‡½æ•°ï¼š
    - `ceilingEntry(key)`ï¼šè¿”å›å¤§äºç­‰äº key çš„æœ€å°å…ƒç´  keyï¼Œä¸å­˜åœ¨åˆ™è¿”å› null
    - `floorEntry(key)`ï¼šè¿”å›å°äºç­‰äº key çš„æœ€å¤§å…ƒç´  keyï¼Œä¸å­˜åœ¨åˆ™è¿”å› null
    - `ceilingEntry(K key)`ï¼šè¿”å› Map.Entry<K, V>
    - `floorEntry(K key)`ï¼šè¿”å› Map.Entry<K, V>



